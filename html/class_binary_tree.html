<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Algorithms: BinaryTree&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_binary_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BinaryTree&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="binarytree_8h_source.html">binarytree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BinaryTree&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_binary_tree.png" usemap="#BinaryTree&lt; T &gt;_map" alt=""/>
  <map id="BinaryTree&lt; T &gt;_map" name="BinaryTree&lt; T &gt;_map">
<area href="class_b_s_t.html" alt="BST&lt; T &gt;" shape="rect" coords="0,56,106,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9202cce23960faf8f647c6765decccd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a9202cce23960faf8f647c6765decccd4">BinaryTree</a> ()</td></tr>
<tr class="separator:a9202cce23960faf8f647c6765decccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390c319c0b28b958463851119edb8af3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a390c319c0b28b958463851119edb8af3">~BinaryTree</a> ()</td></tr>
<tr class="separator:a390c319c0b28b958463851119edb8af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5377ef2e90464a0219734a4a0581e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#abc5377ef2e90464a0219734a4a0581e8">BinaryTree</a> (<a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *root)</td></tr>
<tr class="separator:abc5377ef2e90464a0219734a4a0581e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00bb092f57a5f7ca511e9769651c813"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#ad00bb092f57a5f7ca511e9769651c813">BinaryTree</a> (vector&lt; T &gt; *nodeList)</td></tr>
<tr class="separator:ad00bb092f57a5f7ca511e9769651c813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaf60395d2cb172a37d04143bb29af7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#afaaf60395d2cb172a37d04143bb29af7">BinaryTree</a> (vector&lt; T &gt; *inorderList, vector&lt; T &gt; *preorderList)</td></tr>
<tr class="separator:afaaf60395d2cb172a37d04143bb29af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d42f7f4313056babe8c6b6763c53d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a68d42f7f4313056babe8c6b6763c53d2">printInOrder</a> (vector&lt; T &gt; &amp;inorderList)</td></tr>
<tr class="separator:a68d42f7f4313056babe8c6b6763c53d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa15b4d2df07a15544aa2f19039089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a13aa15b4d2df07a15544aa2f19039089">printInOrderNoRecurse</a> (vector&lt; T &gt; &amp;inorderList)</td></tr>
<tr class="separator:a13aa15b4d2df07a15544aa2f19039089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93ec03d684b832515929a634cbfbd0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#aa93ec03d684b832515929a634cbfbd0f">printPreOrder</a> (vector&lt; T &gt; &amp;preorderList)</td></tr>
<tr class="separator:aa93ec03d684b832515929a634cbfbd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e06c43beaae54825ea87b3262b712e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a72e06c43beaae54825ea87b3262b712e">printPreOrderNoRecurse</a> (vector&lt; T &gt; &amp;preorderList)</td></tr>
<tr class="separator:a72e06c43beaae54825ea87b3262b712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c52ca377e8281b74e6d7e30630be56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#ab1c52ca377e8281b74e6d7e30630be56">printPostOrder</a> (vector&lt; T &gt; &amp;postorderList)</td></tr>
<tr class="separator:ab1c52ca377e8281b74e6d7e30630be56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ea465fd9e70a1887677659359a8ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#ab35ea465fd9e70a1887677659359a8ca">printPostOrderNoRecurse</a> (vector&lt; T &gt; &amp;postorderList)</td></tr>
<tr class="separator:ab35ea465fd9e70a1887677659359a8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb032bd0f25aaf17cf554789ac9f5219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#afb032bd0f25aaf17cf554789ac9f5219">printNormal</a> (vector&lt; T &gt; &amp;normalorderList)</td></tr>
<tr class="separator:afb032bd0f25aaf17cf554789ac9f5219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb5645178a050b3a6d64632ff2f2e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a9cb5645178a050b3a6d64632ff2f2e44">appendNode</a> (<a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *newNode)</td></tr>
<tr class="separator:a9cb5645178a050b3a6d64632ff2f2e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876eb6e9ce70ec7a2f160dd07fce3032"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a876eb6e9ce70ec7a2f160dd07fce3032">find</a> (T val)</td></tr>
<tr class="separator:a876eb6e9ce70ec7a2f160dd07fce3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db8fb5bb050cb3a3526d9e4a114fc62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a5db8fb5bb050cb3a3526d9e4a114fc62">isBalanced</a> (int &amp;height)</td></tr>
<tr class="separator:a5db8fb5bb050cb3a3526d9e4a114fc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255762239b0f7cf9ed39522edb42659b"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_linked_list.html">LinkedList</a>&lt; <a class="el" href="class_tree_node.html">TreeNode</a><br class="typebreak"/>
&lt; T &gt; * &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a255762239b0f7cf9ed39522edb42659b">getLevels</a> ()</td></tr>
<tr class="separator:a255762239b0f7cf9ed39522edb42659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8437fcffcff8be0efb3b269ff88f847f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a8437fcffcff8be0efb3b269ff88f847f">isBST</a> ()</td></tr>
<tr class="separator:a8437fcffcff8be0efb3b269ff88f847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d97724253b250f995f48a7715d05308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a9d97724253b250f995f48a7715d05308">findCommonAncestor</a> (<a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *p, <a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *q)</td></tr>
<tr class="separator:a9d97724253b250f995f48a7715d05308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbc97529d563e9b3f19075b2716370f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a1dbc97529d563e9b3f19075b2716370f">isSubTree</a> (<a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt; *other)</td></tr>
<tr class="separator:a1dbc97529d563e9b3f19075b2716370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57aefc0efc462c54b04e52a1421a94bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#a57aefc0efc462c54b04e52a1421a94bb">getRoot</a> ()</td></tr>
<tr class="separator:a57aefc0efc462c54b04e52a1421a94bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a6a6748be272d5d2485af54d8a6523"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#aa1a6a6748be272d5d2485af54d8a6523">getNodeArray</a> ()</td></tr>
<tr class="separator:aa1a6a6748be272d5d2485af54d8a6523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04b5533c4b3972d305fa2eed4dbda39"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_sum_path.html">SumPath</a>&lt; T &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#ab04b5533c4b3972d305fa2eed4dbda39">findAllPathsWithSum</a> (T sum)</td></tr>
<tr class="separator:ab04b5533c4b3972d305fa2eed4dbda39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc15d2848b29e68baa13898bc70847bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_binary_tree.html#adc15d2848b29e68baa13898bc70847bb">getDiameter</a> ()</td></tr>
<tr class="separator:adc15d2848b29e68baa13898bc70847bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a96a5ae54462dc41b0592ee29cec5ebfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96a5ae54462dc41b0592ee29cec5ebfd"></a>
vector&lt; <a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>nodeArray</b></td></tr>
<tr class="separator:a96a5ae54462dc41b0592ee29cec5ebfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6df3f2b1abf8143e7128891e8bcb7c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6df3f2b1abf8143e7128891e8bcb7c5"></a>
<a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="separator:af6df3f2b1abf8143e7128891e8bcb7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class BinaryTree&lt; T &gt;</h3>

<p>Represents a binary tree data structure. Implements several algorithms related to binary trees. This internally stores two representations of the binary tree: One is normal tree representation with nodes and links between nodes and the other is an array of nodes in breadth-first-search order. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9202cce23960faf8f647c6765decccd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::<a class="el" href="class_binary_tree.html">BinaryTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an empty binary tree. </p>

</div>
</div>
<a class="anchor" id="a390c319c0b28b958463851119edb8af3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::~<a class="el" href="class_binary_tree.html">BinaryTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys this binary tree. </p>

</div>
</div>
<a class="anchor" id="abc5377ef2e90464a0219734a4a0581e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::<a class="el" href="class_binary_tree.html">BinaryTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a binary tree with only one node which becomes the root node. </p>

</div>
</div>
<a class="anchor" id="ad00bb092f57a5f7ca511e9769651c813"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::<a class="el" href="class_binary_tree.html">BinaryTree</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>allNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a binary tree with nodes created from a list of values. The nodes are arranged in the tree in breadth-first order.</p>
<p>Constructs a full binary tree from a vector. This behaves just like a heap, but no heap property is followed.</p>
<p>Time complexity: O(n) Space complexity: O(n) </p>

</div>
</div>
<a class="anchor" id="afaaf60395d2cb172a37d04143bb29af7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::<a class="el" href="class_binary_tree.html">BinaryTree</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>inorderList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>preorderList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconstructs a binary tree from two lists - inorderList and preorderList where these lists are the list of nodes converted from inorder and preorder traversals of the same tree.</p>
<p>Reconstructs a binary tree from the inorder and preorder lists of the same tree. This reconstructs the tree exactly as it was. Only inorder or only preorder listing is not enough to reconstruct the tree exactly as it was, but both together are enough to do so.</p>
<p>Time complexity: O(n^2) Space complexity: O(n) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9cb5645178a050b3a6d64632ff2f2e44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::appendNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a new node to the tree at the end of the tree.</p>
<p>Appends new 'node' to the tree at the end of the tree assuming the tree is a full binary tree. If you have used the constructor which constructs the tree from an array, then you can use this to append more nodes.</p>
<p>Time complexity: O(1) Space complexity: O(1) </p>

</div>
</div>
<a class="anchor" id="a876eb6e9ce70ec7a2f160dd07fce3032"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * &gt; * <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a value in a binary tree and returns the path from root. Returns NULL if val is not found.</p>
<p>Searches for an element 'val' in the binary tree and returns the path from root to that element if found and NULL otherwise.</p>
<p>Uses find recursively on left and right children.</p>
<p>Time complexity: O(n) Space complexity: O(n) </p>

</div>
</div>
<a class="anchor" id="ab04b5533c4b3972d305fa2eed4dbda39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_sum_path.html">SumPath</a>&lt; T &gt; * &gt; * <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::findAllPathsWithSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>sum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all possible paths in the binary tree whose node values sum up to a given sum. Paths can bend around roots. Time complexity: O(n)</p>
<p>Returns all paths in a given binary tree that sum up to a given value. Paths can be any paths including that traverse a root of the sub-tree across.</p>
<p>Time complexity: O(n) Space complexity: O(n) </p>

</div>
</div>
<a class="anchor" id="a9d97724253b250f995f48a7715d05308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::findCommonAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns first common ancestore of given nodes p and q. Time complexity: O(n) Space complexity: O(1)</p>
<p>Finds the common ancestore between two given tree nodes p and q.</p>
<p>Time complexity: O(n) Space complexity: O(1) </p>

</div>
</div>
<a class="anchor" id="adc15d2848b29e68baa13898bc70847bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::getDiameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns diameter of a tree. Diameter of a tree is the longest path between any two nodes of the tree. Time complexity: O(n)</p>
<p>Returns the diameter of a tree. The diameter of a tree is the longest distance between any two nodes in the tree.</p>
<p>Time compexity: O(n) Space complexity: O(1) </p>

</div>
</div>
<a class="anchor" id="a255762239b0f7cf9ed39522edb42659b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_linked_list.html">LinkedList</a>&lt; <a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * &gt; * &gt; * <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::getLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets different levels in the binary tree as a vector of linked lists. Each linked list is a list of siblings at that level. That is the list at index 0 is root, list at index 1 contains two nodes at level 2.</p>
<p>Returns an array of lists, where each list represents one level in the binary tree.</p>
<p>This uses breadth first search technique with a sentinel node pushed at the end of each level.</p>
<p>Time complexity: O(n) Space complexity: O(n) </p>

</div>
</div>
<a class="anchor" id="aa1a6a6748be272d5d2485af54d8a6523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * &gt; * <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::getNodeArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all tree nodes as an array in breadth first order. </p>

</div>
</div>
<a class="anchor" id="a57aefc0efc462c54b04e52a1421a94bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the root of the current tree. </p>

</div>
</div>
<a class="anchor" id="a5db8fb5bb050cb3a3526d9e4a114fc62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::isBalanced </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the binary tree is balanced. The height of the binary tree is put in the height variable.</p>
<p>Determines if this binary tree is balanced or not. Also returns the height of the binary tree in the output parameter 'height'.</p>
<p>Time complexity: O(n) Space complexity: O(1) </p>

</div>
</div>
<a class="anchor" id="a8437fcffcff8be0efb3b269ff88f847f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::isBST </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this binary tree is a binary search tree.</p>
<p>Checks if the current tree is a binary search tree.</p>
<p>Time complexity: O(n) Space complexity: O(1) </p>

</div>
</div>
<a class="anchor" id="a1dbc97529d563e9b3f19075b2716370f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tree_node.html">TreeNode</a>&lt; T &gt; * <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::isSubTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the 'other' binary tree is a sub-tree of the current binary tree and returns a pointer to the root of the sub-tree if it is. Returns NULL otherwise. Time complexity: O(k + nm) - where k is the number of matches of root node of other in the current tree and n is the number of nodes in the current tree and m is the number of nodes in the other tree. NOTE: This is not a tight bound. Space complexity: O(log(n) + log(m))</p>
<p>Checks if the binary tree 'other' is a subtree of the current tree.</p>
<p>Time complexity: O(n * m) where n is the size of the current tree and m is the size of the sub-tree to be matched. Space complexity: O(1) </p>

</div>
</div>
<a class="anchor" id="a68d42f7f4313056babe8c6b6763c53d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::printInOrder </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inorderList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverses the tree inorder and then prints the nodes. It also fills the vector with the nodes in same order. </p>

</div>
</div>
<a class="anchor" id="a13aa15b4d2df07a15544aa2f19039089"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::printInOrderNoRecurse </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inorderList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverses the tree inorder without using recursion and then prints the nodes. It also fills the vector with the nodes in same order. </p>

</div>
</div>
<a class="anchor" id="afb032bd0f25aaf17cf554789ac9f5219"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::printNormal </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>normalorderList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the tree in breadth first order. </p>

</div>
</div>
<a class="anchor" id="ab1c52ca377e8281b74e6d7e30630be56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::printPostOrder </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>postorderList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverse the tree in post-order with recursion. </p>

</div>
</div>
<a class="anchor" id="ab35ea465fd9e70a1887677659359a8ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::printPostOrderNoRecurse </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>postorderList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverses the tree in post-order without recursion. </p>

</div>
</div>
<a class="anchor" id="aa93ec03d684b832515929a634cbfbd0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::printPreOrder </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>preorderList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverses the tree in pre-order by using recursion and prints the nodes (fills the vector 'preorderlist') in same order. </p>

</div>
</div>
<a class="anchor" id="a72e06c43beaae54825ea87b3262b712e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_binary_tree.html">BinaryTree</a>&lt; T &gt;::printPreOrderNoRecurse </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>preorderList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverses the tree in pre-order but without using recursion and fills the vector 'preorderList' with the elements in same order. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="binarytree_8h_source.html">binarytree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2013 14:25:11 for Algorithms by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
